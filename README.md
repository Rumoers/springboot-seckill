## Java秒杀系统设计

参考qiurunze的[miaosha](https://github.com/qiurunze123/miaosha)

### 使用到的技术栈

SpringBoot</br>
SpringCloud</br>
MySQl</br>
Redis</br>
Kafka</br>

## 秒杀核心步骤

1. 用户发起秒杀请求
2. 服务端接受到秒杀请求之后，进行数据的校验
3. redis预减库存，然后判断库存是否已清空(stock=0)，若清空則修改内存标记
4. 将数据成功写入消息队列后，返回操作成功给前端(显示请等待,不是成功也不是失败)
5. 前端接受到操作成功的消息后，开始轮询访问查看秒杀结果方法
6. 消息队列接受到消息后，先进行数据库库存校验，是否重复秒杀。通过后调用service秒杀方法
7. 数据库库存成功-1后返回信息，创建order对象存入数据库。秒杀结束
8. 前端轮询到秒杀结果在前端展示给用户

### 项目亮点

1. 使用分布式Seesion，可以实现让多台服务器同时可以响应。
2. 使用redis做缓存提高访问速度和并发量，减少数据库压力。
3. 使用页面静态化，加快用户访问速度，提高QPS，缓存页面至浏览器，前后端分离降低服务器压力。
4. 使用消息队列完成异步下单，削峰和降流。
5. 安全性优化：双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。

### 缓解数据库压力

项目大量的利用了缓存技术,包括用户信息缓存（分布式session），商品信息的缓存，商品库存缓存，订单的缓存，减少了对数据库服务器的访问。 

### 1.分布式Session

我们知道当服务器集群的时候，若用户第一个请求在第一台服务器上，第二个请求在其他服务器上，会出现session的丢失的情况，丢失用户信息。而且在这种高并发场景下，一定是很多服务器同步工作，所以如何解决session分布式的问题是一个重点。

本项目采用：利用redis缓存的方法，另外布置一个Redis服务器专门用于存放用户的session信息。这样就不会出现用户session丢失的情况。（每次需要session，从缓存中取即可）

### 2.通用缓存key封装

利用一个抽象类，定义BaseKey（前缀）,定义了缓存的String prefix(前缀) 以及缓存的过期时间。让不同模块继承它。

这样每次存入一个模块的缓存的时候，加上这个缓存特定的前缀，以及可以统一制定不同的过期时间。

### 3. 页面静态化以及前后端分离

页面静态化的主要目的是为了加快页面的加载速度。将页面做成静态HTML，数据通过ajax异步请求获取

## 问题

### 使用大量缓存，缓存穿透以及缓存雪崩等问题

解决缓存雪崩：设置不同的过期时间+随机值

解决缓存穿透：在第一次访问时，将不存在的key保存到Redis中

## 使用内存标记减少Redis访问

设置一个Boolean类型内存标记，当redis库存减到0时，将值设为false，当之后再由秒杀请求时，先查看内存标记 ，若为false直接返回，不执行秒杀操作

#### 超卖问题

- 在sql加上判断防止数据边为负数
- 数据库加唯一索引防止用户重复购买
- redis预减库存减少数据库访问　内存标记减少redis访问　请求先入队列缓冲，异步下单，增强用户体验

#### 秒杀安全设计

- 秒杀接口隐藏
- 数字公式验证码
- 接口防刷限流(通用 注解，拦截器防刷)

#### 后续改造

 	1. 使用Vue.js去实现前端界面，前后端分离
 	2. 使用SpringCloud重新构造一个分布式的秒杀系统

